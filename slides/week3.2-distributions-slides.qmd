---
format: 
  revealjs:
    slide-number: true
    # code-link: true
    highlight-style: a11y
    chalkboard: true
    theme: 
      - ../meds-slides-styles.scss
editor_options: 
  chunk_output_type: console
---

## {#title-slide data-menu-title="Title Slide" background="#053660"} 

[EDS 240: Lecture 3.2]{.custom-title}

[*Visualizing distributions*]{.custom-subtitle}

<hr class="hr-teal">

[Week 3 | January 22^nd^, 2024]{.custom-subtitle3}

---

## {#what-is-dist data-menu-title="Data distribution"} 

[Visualizing data *distribution*?]{.slide-title}

<hr>

<br>
<br>
<br>
<br>
<br>
<br>

. . .

<!-- [**Fundamentally:**]{.teal-text}  -->

::: {.body-text-l .center-text}
Visualizing the **spread** of data
:::

<!-- . . .  -->

<!-- [**How?**]{.teal-text} -->

<!-- [...by plotting all possible values or intervals of data, or using summary statistics of all values to indicate their spread.]{.body-text-l} -->

---

## {#viz-dist data-menu-title="Visualizing distributions"} 

["Core" distribution chart types]{.slide-title}

<hr>

```{r}
#| eval: true
#| echo: false
library(palmerpenguins)
library(tidyverse)
library(ggridges)
```

:::: columns

::: {.column width="33%"}
::: {.center-text}
**Histograms**
:::
```{r}
#| eval: true
#| echo: false
#| fig-align: "center"
ggplot(penguins, aes(x = body_mass_g, fill = species)) +
  geom_histogram(alpha = 0.5, position = "identity")
```
:::

::: {.column width="33%"}
::: {.center-text}
**Density plots**
:::
```{r}
#| eval: true
#| echo: false
#| fig-align: "center"
ggplot(penguins, aes(x = body_mass_g, fill = species)) +
  geom_density(alpha = 0.5)
```
:::

::: {.column width="33%"}
::: {.center-text}
**Ridgeline plots**
:::
```{r}
#| eval: true
#| echo: false
#| fig-align: "center"
ggplot(penguins, aes(x = body_mass_g, y = species, fill = species)) +
  ggridges::geom_density_ridges(alpha = 0.5)
```
:::

::::

:::: columns

::: {.column width="50%"}
::: {.center-text}
**Box plots**
:::
```{r}
#| eval: true
#| echo: false
#| fig-align: "center"
#| out-width: "65%"
ggplot(penguins, aes(x = body_mass_g, y = species, fill = species)) +
  geom_boxplot(alpha = 0.5)
```
:::

::: {.column width="50%"}
::: {.center-text}
**Violin plots**
:::
```{r}
#| eval: true
#| echo: false
#| fig-align: "center"
#| out-width: "65%"
ggplot(penguins, aes(x = body_mass_g, y = species, fill = species)) +
  geom_violin(alpha = 0.5)
```
:::

::::

::: footnote
::: {.center-text}
[Examples show the distribution of penguin body masses (g) for Adelie, Chinstrap & Gentoo penguins.]{.body-text-s .gray-text} 
:::
:::

---

## {#mko-temps-intro data-menu-title="About the data"} 

[The data: bottom temperatures at Mohawk Reef]{.slide-title2}

<hr>

The [Santa Barbara Coastal Long Term Ecolgical Research (SBC LTER)](https://sbclter.msi.ucsb.edu/) site was established in 2000 to understand the ecology of coastal kelp forest ecosystems. A number of coastal rocky reef sites are outfitted with instrumentation that collect long-term monitoring data. 

:::: columns

::: {.column width="50%"}
```{r}
#| eval: true
#| echo: false
#| fig-align: "center"
#| out-width: "70%"
#| fig-alt: "A photo of kelp fronds rising towards the ocean's surface."
knitr::include_graphics("images/week3/sbc-logo2.png")
```
:::

::: {.column width="50%"}
```{r}
#| eval: true
#| echo: false
#| fig-align: "center"
#| out-width: "100%"
#| fig-alt: "The Santa Barbara Coastal Long Term Ecological Research site's logo. A creek running down from green mountains to coastal waters meets with ocean waves. Bull kelp floats beneath the surface of the ocean."
knitr::include_graphics("images/week3/sbc-kelp.png")
```
:::

::::

We'll be exploring **bottom temperatures recorded at Mohawk Reef**, a near-shore rocky reef and one of the Santa Barbara Coastal (SBC) LTER research sites.

---

## {#mko-temps-wrangling data-menu-title="Wrangle data"} 

[Data wrangling]{.slide-title}

<hr>

Data are imported directly from the [EDI Data Portal](https://portal.edirepository.org/nis/mapbrowse?scope=knb-lter-sbc&identifier=77). Explore the metadata package online to learn more about these data.

```{r}
#| eval: true
#| echo: true
#..........................load packages.........................
library(tidyverse)
library(chron)
library(naniar)

#..........................import data...........................
mko <- read_csv("https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-sbc.2007.17&entityid=02629ecc08a536972dec021f662428aa")

#..........................wrangle data..........................
mko_clean <- mko |>

  # keep only necessary columns ----
  select(year, month, day, decimal_time, Temp_bot, Temp_top, Temp_mid) |>

  # create datetime column ----
  unite(date, year, month, day, sep = "-", remove = FALSE) |>
  mutate(time = chron::times(as.numeric(decimal_time))) |>
  unite(date_time, date, time, sep = " ") |>

  # coerce data types ----
  mutate(date_time = as.POSIXct(date_time, "%Y-%m-%d %H:%M:%S", tz = "GMT"),
         year = as.factor(year),
         month = as.factor(month),
         day = as.numeric(day),
         Temp_top = as.numeric(Temp_top),
         Temp_mid = as.numeric(Temp_mid),
         Temp_bot = as.numeric(Temp_bot)) |>

  # add month abbreviation ----
  mutate(month_name = as.factor(month.name[month])) |>

  # replace 9999s with NAs ----
  replace_with_na(replace = list(Temp_bot = 9999, Temp_top = 9999, Temp_mid = 9999)) |>

  # select/reorder desired columns ----
  select(date_time, year, month, day, month_name, Temp_bot, Temp_mid, Temp_top)

#......................explore missing data......................

# counts and percentage of missing data by year ----
see_NAs <- mko_clean %>%
  group_by(year) %>%
  naniar::miss_var_summary() |>
  filter(variable == "Temp_bot")

# visualize missing Temp_bot ----
bottom <- mko_clean |> select(Temp_bot)
missing_temps <- naniar::vis_miss(bottom)
```

---

## {#hist-overview data-menu-title="Histogram overview"} 

[Histograms - `ggplot2::geom_histogram()`]{.slide-title2}

<hr>

[**What are they?**]{.teal-text} 

- Histograms are used to represent the **distribution of a *numeric* variable(s)**, which is **cut into several bins**. The number of observations per bin is represented by the height of the bar.

:::: columns 

::: {.column width="50%"}
[**Need:**]{.teal-text} 

- a numeric variable with lots of values
- meaningful differences between values

[**Important considerations:**]{.teal-text} 

- bin width (30 **bins** by default)
- number of groups that you're comparing (generally <=3 is best)
:::

::: {.column width="50%"}
<br>

```{r}
#| eval: true
#| echo: false
#| fig-align: "center"
# ggplot(penguins, aes(x = body_mass_g, fill = species)) +
#   geom_histogram(alpha = 0.5, position = "identity")
mko_clean |> 
  filter(month_name %in% c("April", "June", "October")) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) +
  geom_histogram(position = "identity", alpha = 0.5) +
  scale_fill_manual(values = c("#2C5374", "#ADD8E6", "#8B3A3A"))
```
:::

::::

---

## {#hist-group-num data-menu-title="Histogram group number"} 

[Histograms - best with a few groups]{.slide-title}

<hr>

Twelve groups (`month_name`) is too many groups!
```{r}
#| eval: true
#| echo: true
ggplot(mko_clean, aes(x = Temp_bot, fill = month_name)) +
  geom_histogram(position = "identity", alpha = 0.5)
```

---

## {#hist-updates data-menu-title="Histogram updates"} 

[Histograms - adjustments]{.slide-title}

<hr>

::: panel-tabset

## Fewer groups

Let's instead compare just three months: April (generally the coldest month), October (generally a hot month), June (somewhere in between):
```{r}
#| eval: true
#| echo: true
#| out-width: "50%"
#| code-line-numbers: "1-2,5"
mko_clean |> 
  filter(month_name %in% c("April", "June", "October")) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) + # piping data into ggplot, so don't need to define `data` arg
  geom_histogram(position = "identity", alpha = 0.5)
```

## Adjust colors

Use `fill` to fill bars with a specified color(s) and `color` to outline bars with a specified color(s):
```{r}
#| eval: true
#| echo: true
#| out-width: "50%"
#| code-line-numbers: "3-5"
mko_clean |> 
  filter(month_name %in% c("April", "June", "October")) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) + 
  geom_histogram(position = "identity", alpha = 0.5,  color = "black") +
  scale_fill_manual(values = c("#2C5374", "#ADD8E6", "#8B3A3A"))
```

## Modify bin widths

Modify `binwidth` (**30 `bins`** by default) -- does a bin width of 1 (degree Celsius) actually make sense? Consider scale of interest.
```{r}
#| eval: true
#| echo: true
#| out-width: "50%"
#| code-line-numbers: "4"
mko_clean |> 
  filter(month_name %in% c("April", "June", "October")) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) +
  geom_histogram(position = "identity", alpha = 0.5, binwidth = 1) +
  scale_fill_manual(values = c("#2C5374", "#ADD8E6", "#8B3A3A"))
```

:::

---

## {#density-overview data-menu-title="Density plot overview"} 

[Density plots - `ggplot2::geom_density()`]{.slide-title2}

<hr>

[**What are they?**]{.teal-text} 

- A smoothed version of a histogram. Density plots are representations of the **distribution of a *numeric* variable(s)**, which uses a **[kernel density estimate](https://chemicalstatistician.wordpress.com/2013/06/09/exploratory-data-analysis-kernel-density-estimation-in-r-on-ozone-pollution-data-in-new-york-and-ozonopolis/)** to show the [probability density function](https://en.wikipedia.org/wiki/Probability_density_function) of the variable. The area under each curve is equal to 1.

:::: columns 

::: {.column width="50%"}
[**Need:**]{.teal-text} 

- a numeric variable with lots of values

[**Important considerations:**]{.teal-text} 

- can be misleading with small data sets
- band width, which affects level of smoothing
- number of groups that you're comparing (generally <=3 is best)
:::

::: {.column width="50%"}

<br>

```{r}
#| eval: true
#| echo: false
#| fig-align: "right"
mko_clean |> 
  filter(month_name %in% c("April", "June", "October")) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) +
  geom_density(position = "identity", alpha = 0.5) +
  scale_fill_manual(values = c("#2C5374", "#ADD8E6", "#8B3A3A"))
```
:::

::::

---

## {#density-group-num data-menu-title="Density group number"} 

[Density plots - best with a few groups]{.slide-title}

<hr>

Similar to the histogram, twelve groups (`month_name`) is too many groups!
```{r}
#| eval: true
#| echo: true
ggplot(mko_clean, aes(x = Temp_bot, fill = month_name)) +
  geom_density(alpha = 0.5)
```

---

## {#density-updates data-menu-title="Density plot updates"} 

[Density plots - adjustments]{.slide-title}

<hr>

::: panel-tabset

## Fewer groups

Let's instead compare three months: April (generally the coldest month), October (generally a hot month), June (somewhere in between):
```{r}
#| eval: true
#| echo: true
#| out-width: "50%"
#| code-line-numbers: "1-2,5"
mko_clean |> 
  filter(month_name %in% c("April", "June", "October")) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) +
  geom_density(alpha = 0.5) + 
  scale_fill_manual(values = c("#2C5374", "#ADD8E6", "#8B3A3A"))
```

## Modify band widths

Modify bandwidth by declaring a multiplier of the default bandwidth adjustment. Reducing the `adjust` argument reduces the amount of smoothing (default `adjust = 1`):
```{r}
#| eval: true
#| echo: true
#| out-width: "50%"
#| code-line-numbers: "4"
mko_clean |> 
  filter(month_name %in% c("April", "June", "October")) |> 
  ggplot(aes(x = Temp_bot, fill = month_name)) +
  geom_density(alpha = 0.5, adjust = 1/2) + 
  scale_fill_manual(values = c("#2C5374", "#ADD8E6", "#8B3A3A"))
```

:::

---

## {#density-hist-combo data-menu-title="Density / Histogram combo"} 

[Combining geoms - histogram & density plot]{.slide-title2}

<hr>

Overlaying a histogram and density plot requires scaling down the histogram to match the density curve scale. Adding `y = ..density..` within the `aes()` function rescales the histogram counts so that bar areas integrate to 1:
```{r}
#| eval: true
#| echo: true
ggplot(mko_clean, aes(x = Temp_bot, y = ..density..)) + # scale down hist to match density curve
  geom_histogram(fill = "gray", color = "black", alpha = 0.75) +
  geom_density(size = 1) # increase line thickness
```

::: notes
See <https://stackoverflow.com/questions/46734555/ggplot2-histogram-why-do-y-density-and-stat-density-differ>
:::

---

## {#ridgeline-overview data-menu-title="Ridgeline plot overview"} 

[Ridgeline plots - `{ggridges}`]{.slide-title}

<hr>

[**What are they?**]{.teal-text} 

- Ridgeline plots show the **distribution of a *numeric* variable** for **multiple groups**.

:::: columns 

::: {.column width="50%"}
[**Need:**]{.teal-text} 

- a numeric variable with lots of values
- medium to high group numbers

[**Important considerations:**]{.teal-text} 

- work best when you have > 6 groups
- works well when there is a clear pattern in the result (e.g. if there is an obvious ranking in groups) and/or when visualizing changes in distributions over time or space
:::

::: {.column width="50%"}

<br>

```{r}
#| eval: true
#| echo: false
#| fig-align: "center"
ggplot(mko_clean, aes(x = Temp_bot, y = month_name, fill = after_stat(x))) +
  ggridges::geom_density_ridges_gradient(rel_min_height = 0.01, scale = 3) +
  scale_y_discrete(limits = rev(month.name)) +
  scale_fill_gradientn(colors = c("#2C5374","#778798", "#ADD8E6", "#EF8080", "#8B3A3A"))
```
:::

::::

---

## {#ridgeline-groups data-menu-title="Ridgeline plot group number"} 

[Ridgeline plots - good for multiple groups]{.slide-title}

<hr>

The [`{ggridges}` package](https://wilkelab.org/ggridges/) has a number of different geoms for creating ridgeline plots that work well for datasets with larger group numbers (e.g. `month_name`). Two great geoms to explore (to start):

:::: columns

::: {.column width="50%"}
[`geom_density_ridges()` to create a basic ridgeline plot:]{.body-text-s}
```{r}
#| eval: true
#| echo: true
ggplot(mko_clean, aes(x = Temp_bot, y = month_name)) +
  ggridges::geom_density_ridges()
```
:::

::: {.column width="50%"}
[`geom_density_ridges_gradient()` to fill with a color gradient:]{.body-text-s}
```{r}
#| eval: true
#| echo: true
ggplot(mko_clean, aes(x = Temp_bot, y = month_name, fill = after_stat(x))) +
  ggridges::geom_density_ridges_gradient() +
  scale_fill_gradientn(colors = c("#2C5374","#778798", "#ADD8E6", "#EF8080", "#8B3A3A"))
```
:::

::::

---

## {#ridgeline-adjustments data-menu-title="Ridgeline plot adjustments"} 

[Ridgeline plots - adjustments]{.slide-title}

<hr>

::: panel-tabset

## Group order 

:::: columns

::: {.column width="50%"}
[Order by month (ideal, since months have an inherent order):]{.body-text-s}
```{r}
#| eval: true
#| echo: true
#| code-line-numbers: "3"
ggplot(mko_clean, aes(x = Temp_bot, y = month_name, fill = after_stat(x))) +
  ggridges::geom_density_ridges_gradient() +
  scale_y_discrete(limits = rev(month.name)) +
  scale_fill_gradientn(colors = c("#2C5374","#778798", "#ADD8E6", "#EF8080", "#8B3A3A"))
```
:::

::: {.column width="50%"}
[Order by mean or median (makes more sense when you have unordered groups):]{.body-text-s}
```{r}
#| eval: true
#| echo: true
#| code-line-numbers: "1-2"
mko_clean |> 
  mutate(month_name = fct_reorder(month_name, Temp_bot, .fun = mean)) |> 
  ggplot(mko_clean, mapping = aes(x = Temp_bot, y = month_name, fill = after_stat(x))) +
  ggridges::geom_density_ridges_gradient() +
  scale_fill_gradientn(colors = c("#2C5374","#778798", "#ADD8E6", "#EF8080", "#8B3A3A"))
```
:::

::::

## Overlap & tails

`rel_min_height` adjusts trailing tails and `scale` controls the extent to which the different densities overlap)
```{r}
#| eval: true
#| echo: true
#| code-line-numbers: "2"
#| out-width: "50%"
ggplot(mko_clean, aes(x = Temp_bot, y = month_name, fill = after_stat(x))) +
  ggridges::geom_density_ridges_gradient(rel_min_height = 0.01, scale = 3) +
  scale_y_discrete(limits = rev(month.name)) +
  scale_fill_gradientn(colors = c("#2C5374","#778798", "#ADD8E6", "#EF8080", "#8B3A3A"))
```

## Histogram variant

Make ridgeline plots using histogram bars by updating the `stat` to `"binline"`(filling with a continous scale gradient not advised):
```{r}
#| eval: true
#| echo: true
#| code-line-numbers: "3"
#| out-width: "50%"
ggplot(mko_clean, aes(x = Temp_bot, y = month_name)) +
  ggridges::geom_density_ridges(rel_min_height = 0.01, scale = 3,
                                stat = "binline", binwidth = 1) +
  scale_y_discrete(limits = rev(month.name)) 
```

## Quantiles

Include a median line by using the `stat_density_ridges()` geom and setting the number of `quantiles` to `2`:
```{r}
#| eval: true
#| echo: true
#| code-line-numbers: "3"
#| out-width: "50%"
ggplot(mko_clean, aes(x = Temp_bot, y = month_name)) +
  ggridges::stat_density_ridges(rel_min_height = 0.01, scale = 3,
                                quantile_lines = TRUE, quantiles = 2) +
  scale_y_discrete(limits = rev(month.name))
```

## Jitter raw data

Visualize the raw data underlying the density ridges (since our temperature data is too large (>473,000 rows), so we'll use the `palmerpenguins::penguins` data set to demo):

```{r}
#| eval: true
#| echo: false
library(palmerpenguins)
```

:::: columns

::: {.column width="50%"}
[Jittered points:]{.body-text-s}
```{r}
#| eval: true
#| echo: true
#| code-line-numbers: "2-3"
ggplot(penguins, aes(x = body_mass_g, y = species)) +
  ggridges::geom_density_ridges(jittered_points = TRUE, 
                                alpha = 0.5, point_size = 0.5)
```
:::

<!-- ::: {.column width="33%"} -->
<!-- [Rug plot:]{.body-text-s} -->
<!-- ```{r} -->
<!-- #| eval: true -->
<!-- #| echo: true -->
<!-- #| #| code-line-numbers: "3" -->
<!-- ggplot(penguins, aes(x = body_mass_g, y = species)) + -->
<!--   ggridges::geom_density_ridges(jittered_points = TRUE,  -->
<!--                                 position = position_points_jitter(width = 0.05, height = 0), -->
<!--                                 point_shape = '|', point_size = 3, point_alpha = 1, -->
<!--                                 alpha = 0.7) -->
<!-- ``` -->
<!-- ::: -->

::: {.column width="50%"}
[Raincloud plot:]{.body-text-s}
```{r}
#| eval: true
#| echo: true
#| code-line-numbers: "2-4"
ggplot(penguins, aes(x = body_mass_g, y = species)) +
  ggridges::geom_density_ridges(jittered_points = TRUE, alpha = 0.5, 
                                point_size = 0.5, scale = 0.6,
                                position = "raincloud")
```
:::

::::

:::

---

## {#boxplot-overview data-menu-title="Box plot overview"} 

[Box plots - `ggplot2::geom_boxplot()`]{.slide-title}

<hr>

[**What are they?**]{.teal-text} 

- [Box plots **summarize the distribution of a numeric variable for one or serveral groups**, providing the median (line that divides the box), the upper (Q3) and lower (Q1) [quartiles](https://en.wikipedia.org/wiki/Quartile) (ends of the box), the highest and lowest values, excluding outliers (the whiskers), and potential outliers (dots extending beyond the end of the whiskers).]{.body-text-s}

:::: columns 

::: {.column width="50%"}
[**Need:**]{.teal-text} 

- a numeric variable, often with multiple groups

[**Important considerations:**]{.teal-text} 

- box plots *summarize* data, meaning we can't see the underlying distribution (no way to know sample size)
- add jittered points on top, or if large sample size, consider a violin plot
:::

::: {.column width="50%"}

<br>

```{r}
#| eval: true
#| echo: false
#| fig-align: "center"
ggplot(mko_clean, aes(x = month_name, y = Temp_bot)) +
  geom_boxplot() +
  scale_x_discrete(limits = rev(month.name)) +
  coord_flip()
```
:::

::::

---

## {#boxplot-groups data-menu-title="Box plot group number"} 

[Box plots - good for multiple groups]{.slide-title}

<hr>

Box plots are great for a few to multiple groups (too many boxes just results in a lot of information to synthesize, as a viewer). If your x-axis text is long, consider flipping your axes to make them less crunched:
```{r}
#| eval: true
#| echo: true
#| out-width: "50%"
ggplot(mko_clean, aes(x = month_name, y = Temp_bot)) +
  geom_boxplot() +
  scale_x_discrete(limits = rev(month.name)) +
  coord_flip()
```

---

## {#boxplot-adjustments data-menu-title="Box plot adjustments"} 

[Box plots - adjustments]{.slide-title}

<hr>


::: panel-tabset

## Modify outliers aesthetics

```{r}
#| eval: true
#| echo: true
#| code-line-numbers: "2"
#| out-width: "70%"
ggplot(mko_clean, aes(x = month_name, y = Temp_bot)) +
  geom_boxplot(outlier.colour = "purple", outlier.shape = "circle open", outlier.size = 5) +
  scale_x_discrete(limits = rev(month.name)) +
  coord_flip()
```

## Highlight a group(s)

Highlight a group of interest using the [`{gghighlight}` package](https://yutannihilation.github.io/gghighlight/index.html). Here, we specify a specific month (`"October"`) to highlight:
```{r}
#| eval: true
#| echo: true
#| code-line-numbers: "1-5,8,10"
#| out-width: "30%"
mko_clean |> 
  ggplot(aes(x = month_name, y = Temp_bot, fill = month_name)) +
  geom_boxplot() +
  scale_x_discrete(limits = rev(month.name)) +
  gghighlight::gghighlight(month_name == "October") +
  coord_flip() +
  theme(legend.position = "none")
```

## Jitter raw data

Since box plots hide sample size, consider overlaying raw data points using `geom_jitter()` (since our temperature data is too large (>473,000 rows), weâ€™ll use the `palmerpenguins::penguins` data set to demo):

[NOTE: Be sure to remove outliers, since plotting raw data will result in those data points being a second time:]{.body-text-s}
```{r}
#| eval: true
#| echo: true
#| code-line-numbers: "2-3"
#| out-width: "40%"
ggplot(na.omit(penguins), aes(x = species, y = body_mass_g)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(color = "black", alpha = 0.5) +
  coord_flip()
```

:::

---

## {#violin-plot-overview data-menu-title="Violin plot overview"} 

[Violin plots - `ggplot2::geom_violin()`]{.slide-title}

<hr>

[**What are they?**]{.teal-text} 

- [Violin plots visualize the **distribution of a numeric variable for one or several groups**, where the shape of the violin represents the density estimate of the variable (i.e. the more data points in a specific range, the larger the violin is for that range). They provide more information about the underlying distribution than a box plot.]{.body-text-s}

:::: columns 

::: {.column width="50%"}
[**Need:**]{.teal-text} 

- a numeric variable, often with multiple groups

[**Important considerations:**]{.teal-text}   

- order groups by median value can make it easier to understand  
- show sample size when comparing groups with very different distributions (e.g. half violin plot) 
:::

::: {.column width="50%"}

<br>

```{r}
#| eval: true
#| echo: false
#| fig-align: "center"
ggplot(mko_clean, aes(x = month_name, y = Temp_bot)) +
  geom_violin() +
  scale_x_discrete(limits = rev(month.name)) +
  coord_flip()
```
:::

::::

---

## {#violin-plot-groups data-menu-title="Violin plot group number"} 

[Violin plots - good for multiple groups with lots of data]{.slide-title3}

<hr>

Violin plots are great for a few to multiple groups, and are often a better choice than box plots when you have a very large data set (and overlaying jittered points looks busy or downright unreasonable). If your x-axis text is long, consider flipping your axes to make them less crunched:

```{r}
#| eval: true
#| echo: true
#| out-width: "50%"
ggplot(mko_clean, aes(x = month_name, y = Temp_bot)) +
  geom_violin() +
  scale_x_discrete(limits = rev(month.name)) +
  coord_flip()
```

---

## {#box-violin-combo data-menu-title="Violin & box plot combo"} 

[Combining geoms - violin & box plot]{.slide-title}

<hr>

Overlaying a box plot inside a violin plot can be helpful in providing your audience with summary stats in a compact form:

```{r}
#| eval: true
#| echo: true
#| out-width: "50%"
#| code-line-numbers: "3-4"
ggplot(mko_clean, aes(x = month_name, y = Temp_bot)) +
  geom_violin() +
  geom_boxplot(width = 0.1, color = "gray", alpha = 0.5, 
               outlier.color = "red") +
  scale_x_discrete(limits = rev(month.name)) +
  coord_flip()
```

---

##  {#end-break data-menu-title="# End / Break #" background="#047C90"}

<div class="page-center vertical-center">
<p class="custom-subtitle bottombr">{{< fa mug-hot title="a mug with steam rising out the top" >}} Take a Break</p>
<p class="caption-text">*~ This is the end of Lesson 2 (of 3) ~*</p>
</div>

```{r}
countdown::countdown(
  minutes = 5,
  # left = 0, right = 0,
  # Fanfare when it's over
  play_sound = TRUE,
  color_border              = "#FFFFFF",
  color_text                = "#7aa81e",
  color_running_background  = "#7aa81e",
  color_running_text        = "#FFFFFF",
  color_finished_background = "#ffa07a",
  color_finished_text       = "#FFFFFF",
  font_size = "2em",
  )
```

